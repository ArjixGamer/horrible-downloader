#!/usr/bin/env python

from HorribleDownloader import Parser, ConfigManager
import os
import argparse
import subprocess
from sty import fg

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')


def subscribe_to(show, episode):
    config = ConfigManager()
    p = Parser()
    title = p.get_episodes(show)[0]["title"]  # we want to get the exact name of the show
    if title.lower() in config.conf["subscriptions"]:
        return False, title
    config.conf["subscriptions"][title.lower()] = episode
    with open(os.path.join(config.dir, config.file), 'w') as f:
            config.conf.write(f)

    return True, title

def main(args):
    clear()
    config = ConfigManager()

    # change to custom download dir if user has specified
    if args.output:
        config.download_dir = args.output

    try:
        if args.quiet:
            print('fetching feed...')
        p = Parser()
        qualities = config.quality.split(',') if not args.resolution else args.resolution.split(',')

        # validating qualities object to fit format:
        for quality in qualities:
            if quality not in ["480", "720", "1080"]:
                print("bad resolution specified, aborting...")
                exit(1)

        custom_episodes = []
        if args.episodes:
            for erange in args.episodes.split(','):
                r = erange.split('-')
                if len(r) is 2:
                    custom_episodes.append((float(r[0]), float(r[1])))
                elif len(r) is 1:
                    custom_episodes.append((float(r[0]), float(r[0])))

        download = []
        for show, last_watched in config.subscriptions if not args.download else [(args.download, 0)]:
            if not args.quiet:
                print(f"{fg(3)}FETCHING:{fg.rs} {show}", end="", flush=True)
            batches = [] if not args.batch else p.get_batches(show)
            if not batches:
                episodes = p.get_episodes(show)
                if args.episodes:
                    def in_range(s):
                        return any(map(lambda cep: cep[0] <= float(s["episode"]) <= cep[1], custom_episodes))

                    new = list(filter(in_range, episodes))
                else:
                    new = list(filter(lambda s: float(s["episode"]) > float(last_watched), episodes))
                download.extend(new)
            else:
                download.append(batches[0])

            if not args.quiet:
                dots = "." * (50 - len(str(show)))
                if new or batches:
                    print(f"{dots} {fg(10)}FOUND ({str(len(new))}){fg.rs}")
                else:
                    print(f"{dots} {fg(8)}NONE{fg.rs}")

    except KeyboardInterrupt:
        print(f"{fg(1)}\nexiting...{fg.rs}")
        exit(1)

    if not download:
        if args.download:
            print(fg(1) + "Couldn't find specified anime. Exiting" + fg.rs)
        else:
            print(fg(1) + 'No new episodes were found. Exiting ' + fg.rs)
        exit(1)

    print(f'{fg(2)}\nFound {len(download)} {"files" if len(download) > 1 else "file"} to download:\n{fg.rs}')
    for episode in download:
        for quality in qualities:
            print(f'{episode["title"]} - {episode["episode"]} [{quality}p].mkv')

    inp = input(f'{fg(3)}\nwould you like to proceed? [Y/n] {fg.rs}')
    if inp not in ('', 'Y', 'y', 'yes', 'Yes'):
        print(fg(1) + 'aborting download\n' + fg.rs)
        exit(1)

    # let the downloads begin!
    path = os.path.expanduser(config.download_dir)
    print(f'Beginning download to {path}')
    for show in reversed(download):
        try:
            subdir = os.path.join(path, show['title'].title())
            for quality in qualities:
                subprocess.call(['webtorrent', show[quality]['Magnet'], '-o', subdir])
            if not args.download:
                config.conf['subscriptions'][show['title']] = show['episode'].lstrip('0')
                with open(os.path.join(config.dir, config.file), 'w') as f:
                    config.conf.write(f)
                clear()
        except KeyboardInterrupt:
            continue


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='horrible script for downloading anime')
    parser.add_argument('-d', '--download', help="download a specific anime", type=str)
    parser.add_argument('-o', '--output', help="directory to which it will download the files", type=str)
    parser.add_argument('-e', '--episodes', help="specify specific episodes to download", type=str)
    parser.add_argument('-l', '--list', help="display list of available episodes", action="store_true")
    parser.add_argument('-r', '--resolution', help="specify resolution quality", type=str)
    parser.add_argument('--subscribe', help="add a show to the config file", type=str)
    parser.add_argument('--batch', help="search for batches as well as regular files", action="store_true")
    parser.add_argument('-q', '--quiet', help="set quiet mode on", action="store_true")
    parser.add_argument('-lc', '--list-current', help="list all currently airing shows", action="store_true")
    args = parser.parse_args()
    if args.subscribe:
        episode_number = args.episodes if args.episodes else "0"
        status, show = subscribe_to(args.subscribe, episode_number)
        if status:
            print(f"Successfully subscribed to: \"{show.lower()}\"")
            print(f"Latest watched episode is - {episode_number}")
        else:
            print(f"You're already subscribed to \"{show}\", omitting changes...")
        exit(0)
    if args.list:
        shows = list(Parser().shows.keys())
        print("\n".join(shows))
        exit(0)
    if args.list_current:
        shows = list(Parser().current_shows)
        print("\n".join(shows))
        exit(0)
    main(args)
