#!/usr/bin/env python

from HorribleDownloader import Parser, ConfigManager
import os
import argparse
import subprocess


def clear():
    os.system('cls' if os.name == 'nt' else 'clear')


def subscribe_to(show, episode):
    config = ConfigManager()
    p = Parser()
    title = p.get_episodes(show)[0]["title"].lower()  # we want to get the exact name of the show
    config.conf["subscriptions"][title] = episode
    with open(os.path.join(config.dir, config.file), 'w') as f:
            config.conf.write(f)

    return title

def main(args):
    clear()
    config = ConfigManager()

    # change to custom download dir if user has specified
    if args.output:
        config.download_dir = args.output

    try:
        print('fetching feed...')
        p = Parser()
        qualities = config.quality.split(',') if not args.resolution else args.resolution.split(',')

        # validating qualities object to fit format:
        for quality in qualities:
            if quality not in ["480", "720", "1080"]:
                print("bad resolution specified, aborting...")
                exit(1)

        custom_episodes = []
        if args.episodes:
            for erange in args.episodes.split(','):
                r = erange.split('-')
                if len(r) is 2:
                    custom_episodes.append((float(r[0]), float(r[1])))
                elif len(r) is 1:
                    custom_episodes.append((float(r[0]), float(r[0])))

        download = []
        for show, last_watched in config.subscriptions if not args.download else [(args.download, 0)]:
            batches = p.get_batches(show)
            if not batches:
                episodes = p.get_episodes(show)
                if args.episodes:
                    def in_range(s):
                        return any(map(lambda cep: cep[0] <= float(s["episode"]) <= cep[1], custom_episodes))

                    new = filter(in_range, episodes)
                else:
                    new = filter(lambda s: float(s["episode"]) > float(last_watched), episodes)
                download.extend(new)
            else:
                download.append(batches[0])

    except KeyboardInterrupt:
        print("exiting...")
        exit(1)

    if not download:
        if args.download:
            print("Couldn't find specified anime. Exiting")
        else:
            print('No new episodes were found. Exiting ')
        exit(1)

    print(f'\nFound {len(download)} {"files" if len(download) > 1 else "file"} to download:\n')
    for episode in download:
        for quality in qualities:
            print(f'{episode["title"]} - {episode["episode"]} [{quality}p].mkv')

    inp = input('\nwould you like to proceed? [Y/n] ')
    if inp not in ('', 'Y', 'y', 'yes', 'Yes'):
        print('aborting download\n')
        exit(1)

    # let the downloads begin!
    path = os.path.expanduser(config.download_dir)
    print(f'Beginning download to {path}')
    for show in reversed(download):
        try:
            subdir = os.path.join(path, show['title'].title())
            for quality in qualities:
                subprocess.call(['webtorrent', show[quality]['Magnet'], '-o', subdir])
            if not args.download:
                config.conf['subscriptions'][show['title']] = show['episode'].lstrip('0')
                with open(os.path.join(config.dir, config.file), 'w') as f:
                    config.conf.write(f)
                clear()
        except KeyboardInterrupt:
            continue


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='horrible script for downloading anime')
    parser.add_argument('-d', '--download', help="download a specific anime", type=str)
    parser.add_argument('-o', '--output', help="directory to which it will download the files", type=str)
    parser.add_argument('-e', '--episodes', help="specify specific episodes to download", type=str)
    parser.add_argument('-l', '--list', help="display list of available episodes", action="store_true")
    parser.add_argument('-r', '--resolution', help="specify resolution quality", type=str)
    parser.add_argument('--subscribe', help="add a show to the config file", type=str)
    args = parser.parse_args()
    if args.subscribe:
        episode_number = args.episodes if args.episodes else "0"
        show = subscribe_to(args.subscribe, episode_number)
        print(f"Successfully subscribed to: \"{show}\"")
        print(f"Latest watched episode is - {episode_number}")
        exit(0)
    if args.list:
        shows = list(Parser().shows.keys())
        print("\n".join(shows))
        exit(0)
    main(args)
